#!/usr/bin/env cs
# Generated by CovScript AST Visitor Generator
# Date: Tue Jul 20 15:11:01 2021
package grammar_transfer

import parsergen


class transfer_rule

    #{declaration}
    function trans_repeat_part(node)
        return
    end

    #[declaration]
    function trans_alternative_part(node)
        return
    end

    #term | term
    function trans_declaration(node) 
        return
    end

    #(declaration)
    function trans_declaration_part(node)
        return
    end

end

class new_tree
    var tree = new parsergen.syntax_tree

    function add_node(nodes)
        tree.push_back(nodes)
    end

end

class traversal_old_tree
    var now_statement_name = ""
    var now_tree = new syntax_tree
    var target = system.out
    var indent = -1
    function print_indent()
        foreach i in range(indent) do target.print('\t')
    end
    
    function visit_begin(nodes)
        var idx = 0
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
        end
    end

    function visit_statement(nodes)
        var idx = 0
        # Recursive Visit non_terminal_symbol
        var now_name = ""
        now_name = this.visit_non_terminal_symbol(nodes[idx++].nodes)
        now_statement_name = now_name

        #consume assign_op
        idx++

        # Recursive Visit assign_op
        #this.visit_assign_op(nodes[idx++].nodes)
        
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        
        #consume end_op
        idx++

        # Recursive Visit end_op
        #this.visit_end_op(nodes[idx++].nodes)

    end

    #返回结点数据
    function visit_non_terminal_symbol(nodes)
        var idx = 0
        # Visit id token
        return nodes[idx++].data
        target.print(nodes[idx++].data)
    end

    #record history
    # function visit_assign_op(nodes)
    #     var idx = 0
    #     # Condition
    #     block
    #         var matched = false
    #         if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "::=")
    #             matched = true
    #             # Visit term "::="
    #             ++idx; target.print("::=")
    #         end
    #         if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
    #             matched = true
    #             # Visit term "="
    #             ++idx; target.print("=")
    #         end
    #         if !matched
    #         	# Error
    #         	return
    #         end
    #     end
    # end

    function visit_declaration(nodes)
        var idx = 0
        
        # Recursive Visit term
        var tree = new parsergen.syntax_tree
        tree.root = now_statement_name
        var now_tree = tree

        this.visit_term(nodes[idx++].nodes)
        
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "|")
            # consume term "|"
            ++idx; 

            # Recursive Visit term
            var tree = new parsergen.syntax_tree
            tree.root = now_statement_name
            var now_tree = tree

            this.visit_term(nodes[idx++].nodes)
        end
    end

    #record history
    # function visit_end_op(nodes)
    #     var idx = 0
    #     # Condition
    #     block
    #         var matched = false
    #         if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
    #             matched = true
    #             # Visit term ";"
    #             ++idx; target.print(";")
    #         end
    #         if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
    #             matched = true
    #             # Visit term "."
    #             ++idx; target.print(".")
    #         end
    #         if !matched
    #         	# Error
    #         	return
    #         end
    #     end
    # end
    
    function visit_term(nodes)
        var idx = 0
        # Recursive Visit part
        this.visit_part(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "," || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "part")
            # Optional
            if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                # Visit term ","
                ++idx; target.print(",")
            end
            # Recursive Visit part
            this.visit_part(nodes[idx++].nodes)
        end
    end

    function visit_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "repeat_part")
                matched = true
                # Recursive Visit repeat_part
                this.visit_repeat_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration_part")
                matched = true
                # Recursive Visit declaration_part
                this.visit_declaration_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "alternative_part")
                matched = true
                # Recursive Visit alternative_part
                this.visit_alternative_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "simple_part")
                matched = true
                # Recursive Visit simple_part
                this.visit_simple_part(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_repeat_part(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; target.print("}")
    end

    function visit_declaration_part(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term ")"
        ++idx; target.print(")")
    end

    function visit_alternative_part(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term "]"
        ++idx; target.print("]")
    end
    
    function visit_simple_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "right_non_terminal_symbol")
                matched = true
                # Recursive Visit right_non_terminal_symbol
                this.visit_right_non_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "terminal_symbol")
                matched = true
                # Recursive Visit terminal_symbol
                this.visit_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_right_non_terminal_symbol(nodes)
        var idx = 0
        # Recursive Visit non_terminal_symbol
        this.visit_non_terminal_symbol(nodes[idx++].nodes)
    end
    
    function visit_terminal_symbol(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "slit")
                matched = true
                # Visit slit token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "dlit")
                matched = true
                # Visit dlit token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "token")
                matched = true
                # Visit token token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    


    function run(os, ast)
        this.target = os
        this.visit_begin(ast.nodes)
    end
end






class traversal_new_tree 
    var target = system.out
    var indent = -1
    function print_indent()
        foreach i in range(indent) do target.print('\t')
    end
    #do be deleted
    function visit_assign_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "::=")
                matched = true
                # Visit term "::="
                ++idx; target.print(" ::=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print(" =")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    # //如果只有一个
    # term
    # //否则
    # syntax.cond_or(
    # {term},
    # {term},
    # {term}
    #)    
    function visit_declaration(nodes)
        var idx = 0
        # Recursive Visit term

        if nodes.size <= 1
            this.visit_term(nodes[idx++].nodes)
            return 
        end
        
        indent++
        target.print("syntax.cond_or(\n")
        print_indent()
        target.print("{")
        this.visit_term(nodes[idx++].nodes)
        target.print(" },\n")
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "|")
            # Visit term "|"
            ++idx; 
            print_indent()
            target.print("{")
            this.visit_term(nodes[idx++].nodes)
            target.print(" }")
            if idx + 1 < nodes.size
                target.print(",")
            end
            target.print("\n")
        end
        indent--
        print_indent()
        target.print(")")
    end

    function visit_alternative_part(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term "]"
        ++idx; target.print(" ]")
    end
    function visit_term(nodes)
        var idx = 0
        # Recursive Visit part
        this.visit_part(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "," || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "part")
            # Optional
            if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                # consume term ","
                ++idx; 
            end
            target.print(",")
            # Recursive Visit part
            this.visit_part(nodes[idx++].nodes)
        end
    end
    function visit_right_non_terminal_symbol(nodes)
        var idx = 0
        # Recursive Visit non_terminal_symbol
        target.print("syntax.ref(")
        this.visit_non_terminal_symbol(nodes[idx++].nodes)
        target.print(")")
    end
    function visit_simple_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "right_non_terminal_symbol")
                matched = true
                # Recursive Visit non_terminal_symbol
                this.visit_right_non_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "terminal_symbol")
                matched = true
                # Recursive Visit terminal_symbol
                this.visit_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_non_terminal_symbol(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
    end
    function visit_terminal_symbol(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "slit")
                matched = true
                # Visit slit token
                var dat = nodes[idx++].data
                dat.assign(0, '"')
                dat.assign(dat.size-1, '"')
                target.print("syntax.term(")
                target.print(dat)
                target.print(")")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "dlit")
                matched = true
                # Visit dlit token
                target.print("syntax.term(")
                target.print(nodes[idx++].data)
                target.print(")")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "token")
                matched = true
                # Visit token token
                target.print("syntax.token(\"")
                target.print(nodes[idx++].data)
                target.print("\")")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_declaration_part(nodes)
        var idx = 0
        # consume term "("
        ++idx; 
        target.print("syntax.ref(")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # consume term ")"
        ++idx; 
        target.print(" )")
    end

    #输出
    #@begin
    #var lang_syntax = {
    #    statement ,
    #    statement ,
    #    statement
    #}.to_hash_map()
    #@end    
    function visit_begin(nodes)
        
        var idx = 0
        @begin
        var head = 
        "@begin\n" + 
        "var lang_syntax = {\n"
        @end

        @begin
        var tail = 
        "}.to_hash_map()\n" + 
        "@end\n"
        @end

        target.print(head)
        # Repeat
        indent++
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
            if(idx + 1 <nodes.size)
                target.print(",\n")
            end
        end
        indent--
        target.print("\n")
        target.print(tail)
    end

    #indent? "non_terminal_simbol" : {
    #indent? indent? declaration
    #}
    function visit_statement(nodes)
        var idx = 0

        print_indent()
        target.print("\"")
        # Recursive Visit non_terminal_symbol
        this.visit_non_terminal_symbol(nodes[idx++].nodes)
        
        target.print("\" : {\n")
                    
        # Recursive Visit assign_op //不需要遍历输出相关信息 
        # this.visit_assign_op(nodes[idx++].nodes) 
        # consume assign_op
        idx++
        indent++
        print_indent()
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        indent--
        target.print("\n")
        print_indent()
        target.print("}")
        # Recursive Visit end_op //不需要遍历输出相关信息
        # this.visit_end_op(nodes[idx++].nodes)
        # consume end_op
        idx++
    end
    #syntax.repeat()
    function visit_repeat_part(nodes)
        var idx = 0
        
        ++idx;
        #consume term "()
        target.print("syntax.repeat(")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        #consume term ")"
        ++idx; 
        target.print(")")
    end
    #to be deleted
    function visit_end_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # consume term ";"
                ++idx;
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                matched = true
                # consume term "."
                ++idx;
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_part(nodes)
        var idx = 0
        # Condition
        target.print(" ")
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "repeat_part")
                matched = true
                # Recursive Visit repeat_part
                this.visit_repeat_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration_part")
                matched = true
                # Recursive Visit declaration_part
                this.visit_declaration_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "alternative_part")
                matched = true
                # Recursive Visit alternative_part
                this.visit_alternative_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "simple_part")
                matched = true
                # Recursive Visit simple_part
                this.visit_simple_part(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function run(os, ast)
        this.target = os
        indent++
        this.visit_begin(ast.nodes)
    end
end