#!/usr/bin/env cs
# Generated by CovScript AST Visitor Generator
# Date: Tue Jul 20 15:11:01 2021
package ebnf_ast_visitor
import parsergen
class main
    var target = system.out
    var indent = -1
    function print_indent()
        foreach i in range(indent) do target.print('\t')
    end
    function visit_assign_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "::=")
                matched = true
                # Visit term "::="
                ++idx; target.print("::=")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print("=")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_declaration(nodes)
        var idx = 0
        # Recursive Visit term
        this.visit_term(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "|")
            # Visit term "|"
            ++idx; target.print("|")
            # Recursive Visit term
            this.visit_term(nodes[idx++].nodes)
        end
    end
    function visit_alternative_part(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term "]"
        ++idx; target.print("]")
    end
    function visit_right_non_terminal_symbol(nodes)
        var idx = 0
        # Recursive Visit non_terminal_symbol
        this.visit_non_terminal_symbol(nodes[idx++].nodes)
    end
    function visit_simple_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "right_non_terminal_symbol")
                matched = true
                # Recursive Visit right_non_terminal_symbol
                this.visit_right_non_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "terminal_symbol")
                matched = true
                # Recursive Visit terminal_symbol
                this.visit_terminal_symbol(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_term(nodes)
        var idx = 0
        # Recursive Visit part
        this.visit_part(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "," || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "part")
            # Optional
            if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                # Visit term ","
                ++idx; target.print(",")
            end
            # Recursive Visit part
            this.visit_part(nodes[idx++].nodes)
        end
    end
    function visit_terminal_symbol(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "slit")
                matched = true
                # Visit slit token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "dlit")
                matched = true
                # Visit dlit token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "token")
                matched = true
                # Visit token token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_declaration_part(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_non_terminal_symbol(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
    end
    function visit_begin(nodes)
        var idx = 0
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
        end
    end
    function visit_statement(nodes)
        var idx = 0
        # Recursive Visit non_terminal_symbol
        this.visit_non_terminal_symbol(nodes[idx++].nodes)
        # Recursive Visit assign_op
        this.visit_assign_op(nodes[idx++].nodes)
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Recursive Visit end_op
        this.visit_end_op(nodes[idx++].nodes)
    end
    function visit_repeat_part(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Recursive Visit declaration
        this.visit_declaration(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; target.print("}")
    end
    function visit_end_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print(";")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                matched = true
                # Visit term "."
                ++idx; target.print(".")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "repeat_part")
                matched = true
                # Recursive Visit repeat_part
                this.visit_repeat_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration_part")
                matched = true
                # Recursive Visit declaration_part
                this.visit_declaration_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "alternative_part")
                matched = true
                # Recursive Visit alternative_part
                this.visit_alternative_part(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "simple_part")
                matched = true
                # Recursive Visit simple_part
                this.visit_simple_part(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function run(os, ast)
        this.target = os
        this.visit_begin(ast.nodes)
    end
end
