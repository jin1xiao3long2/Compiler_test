#!/usr/bin/env cs
# Generated by CovScript AST Visitor Generator
# Date: Fri Jul 30 13:03:27 2021
package ast_visitor
import parsergen
import parse_new_grammar
class main
    
    var target = system.out
    var indent = -1

    var output = new array
    var now_var_table = new hash_map
    var now_var_seg = new hash_map
    var now_var_seg_offset = 0
    var now_in_seg = false
    var now_var_offset = 0
    var now_domain = ""
    var now_domain_idx = 0
    var now_var_idx = -1
    var now_count = 0
    var now_var_name = "WRONG NAME"
    var now_fun_name = "WRONG FUN NAME"
    var now_var_type = "WRONG TYPE"
    var now_var_instore = new array
    var now_cmp_type = false

    
    function show_var_table()
        if now_var_table.empty()
            # system.out.println("EMPTY")
            return 
        end
        foreach iter in now_var_table do system.out. println("var : " + iter.first + " , offset " + iter.second)
    end


    function visit_program(nodes)
        var idx = 0
        # Recursive Visit program_0_rep_1
        this.visit_program_0_rep_1(nodes[idx++].nodes)
    end

    function visit_program_0_rep_1(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "external_declaration")
                matched = true
                # Recursive Visit external_declaration
                this.visit_external_declaration(nodes[idx++].nodes)
                # Recursive Visit program_0_rep_1
                this.visit_program_0_rep_1(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_external_declaration(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "struct_specifier")
                matched = true
                # Recursive Visit struct_specifier
                this.visit_struct_specifier(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "function_declaration")
                matched = true
                # Recursive Visit function_declaration
                this.visit_function_declaration(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_function_declaration(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        now_var_offset = 0
        now_var_seg.clear()
        now_var_seg_offset = 0
        now_var_table.clear()
        this.visit_type_specifier(nodes[idx++].nodes)
        # Recursive Visit function_declarator
        this.visit_function_declarator(nodes[idx++].nodes)
        # Recursive Visit compound_statement
        
        this.visit_compound_statement(nodes[idx++].nodes)
    end

    function visit_type_specifier(nodes)
        var idx = 0
        # Visit ID token
        var typename = nodes[idx++].nodes[0].root
        now_var_type = typename
        # target.print(typename)
    end

    function visit_function_declarator(nodes)
        var idx = 0
        # Visit ID token
        var ID = nodes[idx++].nodes[0].root

        # target.print(ID)
        now_domain = ID
        now_domain_idx = 0

        output.push_back("SUBP " + ID)

        # Visit term "("
        ++idx; 
        # target.print("(")
        # Recursive Visit function_declarator_0_opt_3
        this.visit_function_declarator_0_opt_3(nodes[idx++].nodes)
        # Visit term ")"
        ++idx; 
        # target.println(")")
    end

    function visit_function_declarator_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "parameter_list")
                matched = true
                # Recursive Visit parameter_list
                this.visit_parameter_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_constant_expression(nodes)
        var idx = 0
        # Recursive Visit relat_expression
        this.visit_relat_expression(nodes[idx++].nodes)
    end

    function visit_parameter_list(nodes)
        var idx = 0
        # Recursive Visit parameter_declaration
        this.visit_parameter_declaration(nodes[idx++].nodes)
        # Recursive Visit parameter_list_0_rep_2
        this.visit_parameter_list_0_rep_2(nodes[idx++].nodes)
    end

    function visit_parameter_list_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; 
                # target.print(",")
                # Recursive Visit parameter_declaration
                this.visit_parameter_declaration(nodes[idx++].nodes)
                # Recursive Visit parameter_list_0_rep_2
                this.visit_parameter_list_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_parameter_declaration(nodes)
        var idx = 0
        # Recursive Visit declaration_specifier
        this.visit_declaration_specifier(nodes[idx++].nodes)
        # Visit ID token
        var ID = nodes[idx++].nodes[0].root
        # target.print(ID)
        now_var_table.insert(ID, now_var_offset++)
    end

    function visit_declaration_specifier(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        this.visit_type_specifier(nodes[idx++].nodes)
    end

    #进入新的一个域, 记录并继承当前变量表, 离开该域后, 解退(进行弹栈)
    function visit_compound_statement(nodes)
        var idx = 0
        #instore old data
        var before_domain = now_domain
        var before_domain_idx = now_domain_idx
        var before_var_table = now_var_table
        var before_var_offset = now_var_offset
        var before_var_seg_offset = now_var_seg_offset
        var before_var_seg = now_var_seg

        # show_var_table()

        # Visit term "{"
        ++idx; 
        # target.println("{")
        # Recursive Visit compound_statement_0_rep_2
        this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; 
        # target.println("}")

        #弹栈
        #小于零则不弹
        if now_var_table.size != before_var_table.size
            output.push_back("SPOP " + to_string(now_var_table.size - before_var_table.size))
        end
        #恢复数据
        now_domain = before_domain
        now_domain_idx = before_domain_idx
        now_var_table = before_var_table
        now_var_offset = before_var_offset
        now_var_seg = before_var_seg
        now_var_seg_offset = before_var_seg_offset
    end

    function visit_compound_statement_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "statement")
                matched = true
                # Recursive Visit statement
                this.visit_statement(nodes[idx++].nodes)
                # Recursive Visit compound_statement_0_rep_2
                this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
                # Recursive Visit compound_statement_0_rep_2
                this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_declaration(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        this.visit_type_specifier(nodes[idx++].nodes)
        # Recursive Visit init_declarator
        this.visit_init_declarator(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; 
        # target.println(";")
    end
    
    function visit_init_declarator(nodes)
        var idx = 0
        # Visit term "ID"
        var is_seg_data = false
        var ID = nodes[idx++].nodes[0].root
        # target.print(ID)

        if nodes[1].nodes[0].root == "["
            now_in_seg = true
            is_seg_data = true
        end
        if !now_in_seg
            if !now_var_table.exist(ID)
                now_var_table.insert(ID, now_var_offset++)
            else
                now_var_table.at(ID) = now_var_offset++
            end
        else
            if !now_var_seg.exist(ID)
                now_var_seg.insert(ID, now_var_seg_offset++)
            else
                now_var_seg.at(ID) = now_var_seg_offset++
            end
        end
        now_in_seg = false
        # Recursive Visit init_declarator_0_rep_2
        this.visit_init_declarator_0_rep_2(nodes[idx++].nodes)
        # Recursive Visit init_declarator_0_opt_3
        this.visit_init_declarator_0_opt_3(nodes[idx++].nodes)

        if is_seg_data
            now_var_seg_offset--
            var inst = "DATA "
            inst = inst + now_var_type + " "
            inst += to_string(now_var_instore.size)
            foreach iter in now_var_instore
                var add_iter = to_string(iter)
                if now_var_type == "float"
                    if add_iter.find(".", 0 ) < 0
                        add_iter += ".0"
                    end
                end
                inst = inst + " " + add_iter
            end
            output.push_back(inst)
            now_var_instore.clear()
        end
        
    end

    function visit_init_declarator_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "=")
                matched = true
                # Visit term "="
                ++idx; 
                # target.print("=")
                # Recursive Visit initializer
                this.visit_initializer(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_init_declarator_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "[")
                matched = true
                # Visit term "["
                ++idx; 
                # target.print("[")
                # Recursive Visit init_declarator_0_rep_2_0_opt_2
                this.visit_init_declarator_0_rep_2_0_opt_2(nodes[idx++].nodes)
                # Visit term "]"
                ++idx; 
                # target.print("]")
                # Recursive Visit init_declarator_0_rep_2
                this.visit_init_declarator_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_init_declarator_0_rep_2_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "constant_expression")
                matched = true
                # Recursive Visit constant_expression
                this.visit_constant_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "{")
                matched = true
                # Visit term "{"
                ++idx; 
                # target.print("{")
                now_in_seg = true
                # Recursive Visit initializer_list
                this.visit_initializer_list(nodes[idx++].nodes)
                # Recursive Visit initializer_1_opt_3
                this.visit_initializer_1_opt_3(nodes[idx++].nodes)
                # Visit term "}"
                ++idx; 
                # target.print("}")
                now_in_seg = false
            end
            if !matched && (nodes[idx].root == "assignment_expression")
                matched = true
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                if now_in_seg
                    now_var_seg_offset++
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer_1_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; 
                # target.print(",")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer_list(nodes)
        var idx = 0
        # Recursive Visit initializer
        this.visit_initializer(nodes[idx++].nodes)
        # Recursive Visit initializer_list_0_rep_2
        this.visit_initializer_list_0_rep_2(nodes[idx++].nodes)
    end

    
    function visit_initializer_list_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; 
                # target.print(",")
                # Recursive Visit initializer
                this.visit_initializer(nodes[idx++].nodes)
                # Recursive Visit initializer_list_0_rep_2
                this.visit_initializer_list_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
  
    function visit_statement(nodes)
        var idx = 0
        # Condition

        block
            var matched = false
            if !matched && (nodes[idx].root == "return_statement")
                matched = true
                # Recursive Visit return_statement
                this.visit_return_statement(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "iteration_statement")
                matched = true
                # Recursive Visit iteration_statement
                var old_domain = now_domain
                now_domain += "_iter_" + now_domain_idx++
                var old_domain_idx = now_domain_idx
                now_domain_idx = 0
                this.visit_iteration_statement(nodes[idx++].nodes)
                now_domain = old_domain
                now_domain_idx = old_domain_idx
            end
            if !matched && (nodes[idx].root == "selection_statement")
                matched = true
                # Recursive Visit selection_statement
                var old_domain = now_domain
                now_domain += "_select_" + now_domain_idx++
                var old_domain_idx = now_domain_idx
                now_domain_idx = 0
                this.visit_selection_statement(nodes[idx++].nodes)
                now_domain = old_domain
                now_domain_idx = old_domain_idx
            end
            if !matched && (nodes[idx].root == "expression_statement")
                matched = true
                # Recursive Visit expression_statement
                this.visit_expression_statement(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "compound_statement")
                matched = true
                # Recursive Visit compound_statement
                this.visit_compound_statement(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end


    end

    function visit_expression_statement(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
                output.push_back("SPOP 1")
                # Visit term ";"
                ++idx; 
                # target.println(";")
            end
            if !matched && (nodes[idx].root == ";")
                matched = true
                # Visit term ";"
                ++idx; 
                # target.println(";")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    #不需要做缓存表(if)
    #expr
    #cjmp if1
    #else stmt1
    #njmp endif
    #if1 if stmt
    #endif 

    function visit_selection_statement(nodes)
        var idx = 0
        # Visit term "if"
        ++idx; 
        # target.print("if")
        # Visit term "("
        ++idx; 
        # target.print("( ")
        # Recursive Visit expression
        var store_nodes = nodes[idx++]
        #output.push_back(store_nodes)
        #处理store_nodes,需要标记为select_nodes
        this.visit_expression(store_nodes.nodes)
        # Visit term ")"
        ++idx; 
        # target.println(" )")
        # Recursive Visit statement
        
        var startif_domain =  now_domain + "_" + to_string(now_domain_idx++)
        
        output.push_back("CJMP " + startif_domain)
        
        var old_output = output
        output.clear()
        
        output.push_back("FLAG " + startif_domain)
        this.visit_statement(nodes[idx++].nodes)
        var if_output = output
        output = old_output
        # Recursive Visit selection_statement_0_opt_6
        
        this.visit_selection_statement_0_opt_6(nodes[idx++].nodes)
        
        var endif_domain = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("NJMP " + endif_domain)

        foreach inst in if_output do output.push_back(inst)

        output.push_back("FLAG " + endif_domain)
    end

    function visit_selection_statement_0_opt_6(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "else")
                matched = true
                # Visit term "else"
                ++idx; 
                # target.println("else")
                # Recursive Visit statement
                this.visit_statement(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    #for(init; cond; expr) stmt
    #       init
    #COND   cond
    #       CJMP STMT
    #       NJMP ENDFOR
    #STMT   stmt
    #       expr
    #       NJMP COND
    #ENDFOR SPOP

    function visit_iteration_statement(nodes)
        #是否需要push?
        var idx = 0
        # Visit term "for"
        ++idx; 
        # target.print("for")
        # Visit term "("
        ++idx; 
        # target.print("(")
        # Recursive Visit iteration_statement_0_opt_3
        
        var before_domain = now_domain
        var before_domain_idx = now_domain_idx
        var before_var_table = now_var_table
        var before_var_offset = now_var_offset

        #stmt1
        this.visit_iteration_statement_0_opt_3(nodes[idx++].nodes)
        # Visit term ";"
        
        ++idx; 
        # target.print(";")
        var for_judge_flag = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("FLAG " + for_judge_flag)
        # Recursive Visit iteration_statement_0_opt_5
        this.visit_iteration_statement_0_opt_5(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; 
        # target.print(";")

        var stmt_flag = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("CJMP " + stmt_flag)
        var end_flag = now_domain  + "_" + to_string(now_domain_idx++)
        output.push_back("NJMP " + end_flag)

        # Recursive Visit iteration_statement_0_opt_7
        output.push_back("FLAG " + stmt_flag)
        var old_output = output
        output.clear()
        this.visit_iteration_statement_0_opt_7(nodes[idx++].nodes)
        output.push_back("SPOP 1")
        # Visit term ")"
        ++idx; 
        # target.println(")")
        # Recursive Visit statement
        var change_output = output
        output = old_output
        this.visit_statement(nodes[idx++].nodes)
        
        foreach inst in change_output do output.push_back(inst)

        output.push_back("NJMP " + for_judge_flag)
        output.push_back("FLAG " + end_flag)

        #弹栈
        if now_var_table.size != before_var_table
            output.push_back("SPOP " + to_string(now_var_table.size - before_var_table.size))
        end
        #恢复数据
        now_domain = before_domain
        now_domain_idx = before_domain_idx
        now_var_table = before_var_table
        now_var_offset = before_var_offset
    end

    function visit_iteration_statement_0_opt_7(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement_0_opt_5(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                output.push_back("PUSH 1")
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "iteration_statement_0_opt_3_0_opt_1")
                matched = true
                # Recursive Visit iteration_statement_0_opt_3_0_opt_1
                # Recursive Visit init_declarator
                var old_var_table = now_var_table
                var old_var_offset = now_var_offset

                this.visit_iteration_statement_0_opt_3_0_opt_1(nodes[0].nodes)
                this.visit_init_declarator(nodes[1].nodes)

                
                if nodes[0].nodes[0].root == "NULL"
                    now_var_table = old_var_table
                    now_var_offset = old_var_offset
                end
                
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement_0_opt_3_0_opt_1(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "type_specifier")
                matched = true
                # Recursive Visit type_specifier
                this.visit_type_specifier(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_return_statement(nodes)
        var idx = 0
        # Visit term "return"
        ++idx; 
        # target.print("return")
        # Recursive Visit expression_statement

        this.visit_return_statement_0_opt_2(nodes[idx++].nodes)
        # target.print(";")
        output.push_back("RETP")
    end

    function visit_return_statement_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit type_specifier
                this.visit_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    function visit_expression(nodes)
        var root_node = new parse_new_grammar.tree_type
        root_node.nodes = nodes
        root_node.root = "expression"
        # output.push_back(root_node)
        var idx = 0
        # Recursive Visit assignment_expression
        this.visit_assignment_expression(nodes[idx++].nodes)
        # Recursive Visit expression_0_rep_2
        this.visit_expression_0_rep_2(nodes[idx++].nodes)
    end

    function visit_expression_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; 
                # target.print(",")
                output.push_back("SPOP 1")
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                # Recursive Visit expression_0_rep_2
                this.visit_expression_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_assignment_expression(nodes)
        var idx = 0
        # Recursive Visit equality_expression
        this.visit_equality_expression(nodes[idx++].nodes)
        # Recursive Visit assignment_expression_0_opt_2
        this.visit_assignment_expression_0_opt_2(nodes[idx++].nodes)
    end
    
    function visit_assignment_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "assign_op")
                matched = true

                #暂不确定是否合理,这里主要是获得赋值元素的偏移量
                if nodes[0].nodes[0].root == "="
                    output.pop_back()
                end

                var old_var_idx = now_var_idx
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[1].nodes)

                now_var_idx = old_var_idx
                # Recursive Visit assign_op
                this.visit_assign_op(nodes[0].nodes)
                
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_assign_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "/=")
                matched = true
                # Visit term "/="
                ++idx; 
                # target.print("/=")
                output.push_back("SDIV")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched && (nodes[idx].root == "*=")
                matched = true
                # Visit term "*="
                ++idx; 
                # target.print("*=")
                output.push_back("SMUL")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched && (nodes[idx].root == "-=")
                matched = true
                # Visit term "-="
                ++idx; 
                # target.print("-=")
                output.push_back("SSUB")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched && (nodes[idx].root == "+=")
                matched = true
                # Visit term "+="
                ++idx; 
                # target.print("+=")
                output.push_back("SADD")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched && (nodes[idx].root == "=")
                matched = true
                # Visit term "="
                ++idx; 
                # target.print("=")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_equality_expression(nodes)
        var idx = 0

        var euqal_expr_0_opt2 = nodes[1]
        var sign = ""

        if !euqal_expr_0_opt2.nodes[0].root == "NULL"
            sign = euqal_expr_0_opt2.nodes[0].nodes[0].root
        end

        if sign == ""
            this.visit_relat_expression(nodes[0].nodes)
            return
        else
            now_cmp_type = false
            this.visit_relat_expression(nodes[0].nodes)
            this.visit_equality_expression(nodes[1].nodes[1].nodes)
            this.visit_equal_op(nodes[1].nodes[0].nodes)
            return
            
        end
    end
    
    function visit_equality_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "equal_op")
                matched = true
                # Recursive Visit equal_op
                this.visit_equal_op(nodes[idx++].nodes)
                # Recursive Visit equality_expression
                this.visit_equality_expression(nodes[idx++].nodes)     
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_equal_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "!=")
                matched = true
                # Visit term "!="
                ++idx; 
                # target.print("!=")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == "==")
                matched = true
                # Visit term "=="
                ++idx; 
                # target.print("==")
                output.push_back("SSUB")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_relat_expression(nodes)
        var idx = 0

        var relat_expr_0_opt2 = nodes[1]
        var sign = ""

        if !relat_expr_0_opt2.nodes[0].root == "NULL"
            sign = relat_expr_0_opt2.nodes[0].nodes[0].root
        end

        if sign == ""
            this.visit_additive_expression(nodes[0].nodes)
            return
        else
            now_cmp_type = true
            if sign == ">=" || sign == ">"
                this.visit_additive_expression(nodes[0].nodes)
                this.visit_relat_expression(nodes[1].nodes[1].nodes)
                this.visit_relat_op(nodes[1].nodes[0].nodes)
                return
            else
                this.visit_relat_expression(nodes[1].nodes[1].nodes)
                this.visit_additive_expression(nodes[0].nodes)
                this.visit_relat_op(nodes[1].nodes[0].nodes)
                return 
            end
        end
    end

    function visit_relat_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "relat_op")
                matched = true
                # Recursive Visit relat_op
                this.visit_relat_op(nodes[idx++].nodes)
                # Recursive Visit relat_expression
                this.visit_relat_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_relat_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "<=")
                matched = true
                # Visit term "<="
                ++idx; 
                # target.print("<=")
                output.push_back("ISUB 1")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == ">=")
                matched = true
                # Visit term ">="
                ++idx; 
                # target.print(">=")
                output.push_back("ISUB 1")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == "<")
                matched = true
                # Visit term "<"
                ++idx; 
                # target.print("<")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == ">")
                matched = true
                # Visit term ">"
                ++idx; 
                # target.print(">")
                output.push_back("SSUB")
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    
    function visit_additive_expression(nodes)
        var idx = 0
        # Recursive Visit multiplicative_expression
        this.visit_multiplicative_expression(nodes[idx++].nodes)
        # Recursive Visit additive_expression_0_opt_2
        this.visit_additive_expression_0_opt_2(nodes[idx++].nodes)
    end


    function visit_additive_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "add_op")
                matched = true
                
                # Recursive Visit additive_expression
                this.visit_additive_expression(nodes[1].nodes)

                # Recursive Visit add_op
                
                this.visit_add_op(nodes[0].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_add_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "-")
                matched = true
                # Visit term "-"
                ++idx; 
                # target.print("-")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == "+")
                matched = true
                # Visit term "+"
                ++idx; 
                # target.print("+")
                output.push_back("SADD")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_multiplicative_expression(nodes)
        var idx = 0
        # Recursive Visit unary_expression
        this.visit_unary_expression(nodes[idx++].nodes)
        # Recursive Visit multiplicative_expression_0_opt_2
        this.visit_multiplicative_expression_0_opt_2(nodes[idx++].nodes)
    end

    function visit_multiplicative_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "mul_op")
                matched = true
                
                # Recursive Visit multiplicative_expression
                this.visit_multiplicative_expression(nodes[1].nodes)

                # Recursive Visit mul_op
                this.visit_mul_op(nodes[0].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_mul_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "/")
                matched = true
                # Visit term "/"
                ++idx; 
                # target.print("/")
                output.push_back("SDIV")
            end
            if !matched && (nodes[idx].root == "*")
                matched = true
                # Visit term "*"
                ++idx; 
                # target.print("*")
                output.push_back("SMUL")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_unary_expression(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "postfix_expression")
                matched = true
                # Recursive Visit postfix_expression
                this.visit_postfix_expression(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "sadd_op")
                matched = true
                # Recursive Visit sadd_op
                if nodes[idx].nodes[0].root == "-"
                    output.push_back("PUSH 0")
                end
                var old_output = output
                output.clear()
                this.visit_sadd_op(nodes[idx++].nodes)
                # Recursive Visit unary_expression
                var sadd_output = output
                output = old_output
                this.visit_unary_expression(nodes[idx++].nodes)
                foreach iter in sadd_output do output.push_back(iter)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_sadd_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "-")
                matched = true
                # Visit term "-"
                ++idx; 
                # target.print("-")
                output.push_back("SSUB")
            end
            if !matched && (nodes[idx].root == "--")
                matched = true
                # Visit term "--"
                ++idx; 
                # target.print("--")
                output.push_back("ISUB 1")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched && (nodes[idx].root == "++")
                matched = true
                # Visit term "++"
                ++idx; 
                # target.print("++")
                output.push_back("IADD 1")
                output.push_back("COPY f0 " + now_var_idx)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_expression(nodes)
        var idx = 0
        # Recursive Visit primary_expression
        this.visit_primary_expression(nodes[idx++].nodes)
        # Recursive Visit postfix_expression_0_rep_2
        this.visit_postfix_expression_0_rep_2(nodes[idx++].nodes)
    end

    function visit_postfix_expression_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "postfix_extend_part")
                matched = true
                # Recursive Visit postfix_extend_part
                this.visit_postfix_extend_part(nodes[idx++].nodes)
                # Recursive Visit postfix_expression_0_rep_2
                this.visit_postfix_expression_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "post_op")
                matched = true
                # Recursive Visit post_op
                this.visit_post_op(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == ".")
                matched = true
                # Visit term "."
                ++idx; 
                # target.print(".")
                # Visit ID token
                target.print(nodes[idx++].nodes[0].root)
            end
            if !matched && (nodes[idx].root == "(")
                matched = true
                # Visit term "("
                var old_fun_name = now_fun_name
                now_fun_name = now_var_name
                ++idx; 
                # target.print("(")
                # Recursive Visit postfix_extend_part_1_opt_2
                this.visit_postfix_extend_part_1_opt_2(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; 
                # target.print(")")
                now_fun_name = old_fun_name
            end
            if !matched && (nodes[idx].root == "[")
                matched = true
                # Visit term "["
                ++idx; 
                # target.print("[")
                # Recursive Visit expression
                var mID = now_var_name
                this.visit_expression(nodes[idx++].nodes)
                if now_var_seg.at(mID) != 0
                    output.push_back("IADD " + now_var_seg.at(mID))
                end
                output.push_back("PDAT ffff")
                # Visit term "]"
                ++idx; 
                # target.print("]")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part_1_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "assignment_expression")
                matched = true
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                now_count = 1
                # Recursive Visit postfix_extend_part_1_opt_2_0_rep_2
                this.visit_postfix_extend_part_1_opt_2_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part_1_opt_2_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
                output.push_back("CALL " + now_count + " " +now_fun_name)
                now_count = 0
                now_var_name = "WRONG NAME"
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; 
                # target.print(",")
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                now_count++
                # Recursive Visit postfix_extend_part_1_opt_2_0_rep_2
                this.visit_postfix_extend_part_1_opt_2_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_post_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "--")
                matched = true
                # Visit term "--"
                ++idx; 
                # target.print("--")
                output.push_back("ISUB 1")
                output.push_back("COPY f0 " + now_var_idx)
                output.push_back("IADD 1")
            end
            if !matched && (nodes[idx].root == "++")
                matched = true
                # Visit term "++"
                ++idx; 
                # target.print("++")
                output.push_back("IADD 1")
                output.push_back("COPY f0 " + now_var_idx)
                output.push_back("ISUB 1")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_primary_expression(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "(")
                matched = true
                # Visit term "("
                ++idx; 
                # target.print("( ")
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; 
                # target.print(" )")
            end
            if !matched && (nodes[idx].root == "NUMBER")
                matched = true
                # Visit NUMBER token
                var number = nodes[idx++].nodes[0].root
                # target.print(number)
                if !now_in_seg
                    if now_var_type == "float"
                        var num = to_string(number)
                        if num.find(".", 0) < 0
                            num += ".0"
                        end
                        output.push_back("PUSH " + num)
                    else
                        output.push_back("PUSH " + number)
                    end
                else
                    # output.push_back("PUSH " + number)
                    now_var_instore.push_back(number)
                end
            end
            if !matched && (nodes[idx].root == "ID")
                matched = true
                # Visit ID token
                var ID = nodes[idx++].nodes[0].root
                # target.print(ID)
                if now_var_seg.exist(ID)
                    now_var_name = ID
                    return
                end
                if !now_var_table.exist(ID)
                    now_var_name = ID
                    return 
                end
                var offset = now_var_table.at(ID)
                output.push_back("PUSH 00 " + offset)
                now_var_idx = offset
                now_var_name = ID
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    function visit_struct_specifier(nodes)
        var idx = 0
        # Visit term "struct"
        ++idx; 
        # target.print("struct")
        # Visit ID token
        # target.print(nodes[idx++].nodes[0].root)
        # Visit term "{"
        ++idx; 
        # target.println("{")
        # Recursive Visit struct_specifier_0_rep_4
        this.visit_struct_specifier_0_rep_4(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; 
        # target.print("}")
        # Recursive Visit struct_specifier_0_opt_6
        this.visit_struct_specifier_0_opt_6(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; 
        # target.println(";")
    end
    


    function visit_struct_specifier_0_opt_6(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "ID")
                matched = true
                # Visit ID token
                # target.print(nodes[idx++].nodes[0].root)
            end
            if !matched
            	# Error
            	return
            end
        end
    end





    function visit_struct_specifier_0_rep_4(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
                # Recursive Visit struct_specifier_0_rep_4
                this.visit_struct_specifier_0_rep_4(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function show_output()
        var idx = 1
        foreach iter in output
            if idx != output.size
                system.out.println(iter)
            else
                system.out.print(iter)
            end
            # if typeid iter == typeid parse_new_grammar.tree_type
            #     system.out.println("expression")
            # else
            #     system.out.println(iter)
            # end
            idx++
        end
    end

    function ADD_REMOVE_MARK()
        var funcend = 0
        var funcbegin = 0
        var idx = 0
        foreach iter in output
            if iter.find("RETP", 0) >= 0
                funcend = idx
            end
            
            if iter.find("SUBP", 0) >= 0
                funcbegin = idx
                
                for i = funcend + 1, i < funcbegin, i++

                    output[i] += "    REMOVE"
                end 
            end

            idx++
        end

        for i = funcend + 1, i != idx, i++
            # system.out.println(to_string(typeid output[i]) + "  " + to_string(output[i]))
            output[i] = to_string(output[i]) +  "    REMOVE"
        end
    end

    function REMOVE_INST()
        var new_output = new array
        foreach iter in output 
          if !iter.find("REMOVE", 0) >= 0
            new_output.push_back(iter)
            end  
        end
        output = new_output
    end
    function run(ast)
        this.target = system.out
        this.visit_program(ast.nodes)
        ADD_REMOVE_MARK()
        REMOVE_INST()
        show_output()
    end
end
