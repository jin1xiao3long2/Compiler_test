#!/usr/bin/env cs
# Generated by CovScript AST Visitor Generator
# Date: Fri Jul 30 13:03:27 2021
package ast_visitor
import parsergen
import parse_new_grammar
class main
    
    var target = system.out
    var indent = -1

    var output = new array
    var now_var_table = new hash_map
    var now_var_offset = 0
    var now_domain = ""
    var now_domain_idx = 0

    function visit_program(nodes)
        var idx = 0
        # Recursive Visit program_0_rep_1
        this.visit_program_0_rep_1(nodes[idx++].nodes)
    end

    function visit_program_0_rep_1(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "external_declaration")
                matched = true
                # Recursive Visit external_declaration
                this.visit_external_declaration(nodes[idx++].nodes)
                # Recursive Visit program_0_rep_1
                this.visit_program_0_rep_1(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_external_declaration(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "struct_specifier")
                matched = true
                # Recursive Visit struct_specifier
                this.visit_struct_specifier(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "function_declaration")
                matched = true
                # Recursive Visit function_declaration
                this.visit_function_declaration(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_function_declaration(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        now_var_offset = 0
        now_var_table.clear()
        this.visit_type_specifier(nodes[idx++].nodes)
        # Recursive Visit function_declarator
        this.visit_function_declarator(nodes[idx++].nodes)
        # Recursive Visit compound_statement
        
        this.visit_compound_statement(nodes[idx++].nodes)
    end

    function visit_type_specifier(nodes)
        var idx = 0
        # Visit ID token
        target.print(nodes[idx++].nodes[0].root)
    end

    function visit_function_declarator(nodes)
        var idx = 0
        # Visit ID token
        var ID = nodes[idx++].nodes[0].root

        target.print(ID)
        now_domain = ID
        now_domain_idx = 0

        output.push_back("SUBP " + ID)

        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit function_declarator_0_opt_3
        this.visit_function_declarator_0_opt_3(nodes[idx++].nodes)
        # Visit term ")"
        ++idx; target.println(")")
    end

    function visit_function_declarator_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "parameter_list")
                matched = true
                # Recursive Visit parameter_list
                this.visit_parameter_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_constant_expression(nodes)
        var idx = 0
        # Recursive Visit relat_expression
        this.visit_relat_expression(nodes[idx++].nodes)
    end

    function visit_parameter_list(nodes)
        var idx = 0
        # Recursive Visit parameter_declaration
        this.visit_parameter_declaration(nodes[idx++].nodes)
        # Recursive Visit parameter_list_0_rep_2
        this.visit_parameter_list_0_rep_2(nodes[idx++].nodes)
    end

    function visit_parameter_list_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(",")
                # Recursive Visit parameter_declaration
                this.visit_parameter_declaration(nodes[idx++].nodes)
                # Recursive Visit parameter_list_0_rep_2
                this.visit_parameter_list_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_parameter_declaration(nodes)
        var idx = 0
        # Recursive Visit declaration_specifier
        this.visit_declaration_specifier(nodes[idx++].nodes)
        # Visit ID token
        var ID = nodes[idx++].nodes[0].root
        target.print(ID)
        now_var_table.insert(ID, now_var_offset++)
    end

    function visit_declaration_specifier(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        this.visit_type_specifier(nodes[idx++].nodes)
    end

    #进入新的一个域, 记录并继承当前变量表, 离开该域后, 解退(进行弹栈)
    function visit_compound_statement(nodes)
        var idx = 0
        #instore old data
        var before_domain = now_domain
        var before_domain_idx = now_domain_idx
        var before_var_table = now_var_table
        var before_var_offset = now_var_offset


        # Visit term "{"
        ++idx; target.println("{")
        # Recursive Visit compound_statement_0_rep_2
        this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; target.println("}")

        #弹栈
        output.push_back("SPOP 0 1 " + to_string(now_var_table.size - before_var_table.size))

        #恢复数据
        now_domain = before_domain
        now_domain_idx = before_domain_idx
        now_var_table = before_var_table
        now_var_offset = before_var_offset
    end

    function visit_compound_statement_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "statement")
                matched = true
                # Recursive Visit statement
                this.visit_statement(nodes[idx++].nodes)
                # Recursive Visit compound_statement_0_rep_2
                this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
                # Recursive Visit compound_statement_0_rep_2
                this.visit_compound_statement_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_declaration(nodes)
        var idx = 0
        # Recursive Visit type_specifier
        this.visit_type_specifier(nodes[idx++].nodes)
        # Recursive Visit init_declarator
        this.visit_init_declarator(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; target.println(";")
    end
    
    function visit_init_declarator(nodes)
        var idx = 0
        # Visit term "ID"
        var ID = nodes[idx++].nodes[0].root
        target.print(ID)
        # Recursive Visit init_declarator_0_rep_2
        this.visit_init_declarator_0_rep_2(nodes[idx++].nodes)
        # Recursive Visit init_declarator_0_opt_3
        this.visit_init_declarator_0_opt_3(nodes[idx++].nodes)
    end

    function visit_init_declarator_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "=")
                matched = true
                # Visit term "="
                ++idx; target.print("=")
                # Recursive Visit initializer
                this.visit_initializer(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_init_declarator_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "[")
                matched = true
                # Visit term "["
                ++idx; target.print("[")
                # Recursive Visit init_declarator_0_rep_2_0_opt_2
                this.visit_init_declarator_0_rep_2_0_opt_2(nodes[idx++].nodes)
                # Visit term "]"
                ++idx; target.print("]")
                # Recursive Visit init_declarator_0_rep_2
                this.visit_init_declarator_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_init_declarator_0_rep_2_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "constant_expression")
                matched = true
                # Recursive Visit constant_expression
                this.visit_constant_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "{")
                matched = true
                # Visit term "{"
                ++idx; target.print("{")
                # Recursive Visit initializer_list
                this.visit_initializer_list(nodes[idx++].nodes)
                # Recursive Visit initializer_1_opt_3
                this.visit_initializer_1_opt_3(nodes[idx++].nodes)
                # Visit term "}"
                ++idx; target.print("}")
            end
            if !matched && (nodes[idx].root == "assignment_expression")
                matched = true
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer_1_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(",")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_initializer_list(nodes)
        var idx = 0
        # Recursive Visit initializer
        this.visit_initializer(nodes[idx++].nodes)
        # Recursive Visit initializer_list_0_rep_2
        this.visit_initializer_list_0_rep_2(nodes[idx++].nodes)
    end

    
    function visit_initializer_list_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(",")
                # Recursive Visit initializer
                this.visit_initializer(nodes[idx++].nodes)
                # Recursive Visit initializer_list_0_rep_2
                this.visit_initializer_list_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
  
    function visit_statement(nodes)
        var idx = 0
        # Condition

        block
            var matched = false
            if !matched && (nodes[idx].root == "return_statement")
                matched = true
                # Recursive Visit return_statement
                this.visit_return_statement(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "iteration_statement")
                matched = true
                # Recursive Visit iteration_statement
                var old_domain = now_domain
                now_domain += "_iter_" + now_domain_idx++
                var old_domain_idx = now_domain_idx
                this.visit_iteration_statement(nodes[idx++].nodes)
                now_domain = old_domain
                now_domain_idx = 0
            end
            if !matched && (nodes[idx].root == "selection_statement")
                matched = true
                # Recursive Visit selection_statement
                var old_domain = now_domain
                var old_domain_idx = now_domain_idx
                now_domain += "_select_" + now_domain_idx++
                this.visit_selection_statement(nodes[idx++].nodes)
                now_domain = old_domain
                now_domain_idx = 0
            end
            if !matched && (nodes[idx].root == "expression_statement")
                matched = true
                # Recursive Visit expression_statement
                this.visit_expression_statement(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "compound_statement")
                matched = true
                # Recursive Visit compound_statement
                this.visit_compound_statement(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end


    end

    function visit_expression_statement(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
                # Visit term ";"
                ++idx; target.println(";")
            end
            if !matched && (nodes[idx].root == ";")
                matched = true
                # Visit term ";"
                ++idx; target.println(";")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    #不需要做缓存表(if)
    #expr
    #cjmp if1
    #else stmt1
    #njmp endif
    #if1 if stmt
    #endif 

    function visit_selection_statement(nodes)
        var idx = 0
        # Visit term "if"
        ++idx; target.print("if")
        # Visit term "("
        ++idx; target.print("( ")
        # Recursive Visit expression
        var store_nodes = nodes[idx++]
        output.push_back(store_nodes)
        #处理store_nodes,需要标记为select_nodes
        this.visit_expression(store_nodes.nodes)
        # Visit term ")"
        ++idx; target.println(" )")
        # Recursive Visit statement
        
        var startif_domain =  now_domain + "_" + to_string(now_domain_idx++)
        
        output.push_back("CJMP " + startif_domain)
        
        var old_output = output
        output.clear()
        
        output.push_back("FLAG " + startif_domain)
        this.visit_statement(nodes[idx++].nodes)
        var if_output = output
        output = old_output
        # Recursive Visit selection_statement_0_opt_6
        
        this.visit_selection_statement_0_opt_6(nodes[idx++].nodes)
        
        var endif_domain = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("NJMP " + endif_domain)

        foreach inst in if_output do output.push_back(inst)

        output.push_back("FLAG " + endif_domain)
    end

    function visit_selection_statement_0_opt_6(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "else")
                matched = true
                # Visit term "else"
                ++idx; target.println("else")
                # Recursive Visit statement
                this.visit_statement(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement(nodes)
        #是否需要push?
        var idx = 0
        # Visit term "for"
        ++idx; target.print("for")
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit iteration_statement_0_opt_3

        this.visit_iteration_statement_0_opt_3(nodes[idx++].nodes)
        # Visit term ";"
        
        ++idx; target.print(";")
        var for_judge_flag = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("FLAG " + for_judge_flag)
        # Recursive Visit iteration_statement_0_opt_5
        this.visit_iteration_statement_0_opt_5(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; target.print(";")
        var stmt_flag = now_domain + "_" + to_string(now_domain_idx++)
        output.push_back("CJMP " + stmt_flag)
        var end_flag = now_domain  + "_" + to_string(now_domain_idx++)
        output.push_back("NJMP " + end_flag)
        # Recursive Visit iteration_statement_0_opt_7
        output.push_back("FLAG " + stmt_flag)
        var old_output = output
        output.clear()
        this.visit_iteration_statement_0_opt_7(nodes[idx++].nodes)
        # Visit term ")"
        ++idx; target.println(")")
        # Recursive Visit statement
        var change_output = output
        output = old_output
        this.visit_statement(nodes[idx++].nodes)
        
        foreach inst in change_output do output.push_back(inst)

        output.push_back("NJMP " + for_judge_flag)
        output.push_back("FLAG " + end_flag)
    end

    function visit_iteration_statement_0_opt_7(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    function visit_iteration_statement_0_opt_5(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "expression")
                matched = true
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement_0_opt_3(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "iteration_statement_0_opt_3_0_opt_1")
                matched = true
                # Recursive Visit iteration_statement_0_opt_3_0_opt_1
                this.visit_iteration_statement_0_opt_3_0_opt_1(nodes[idx++].nodes)
                # Recursive Visit init_declarator
                this.visit_init_declarator(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_iteration_statement_0_opt_3_0_opt_1(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "type_specifier")
                matched = true
                # Recursive Visit type_specifier
                this.visit_type_specifier(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_return_statement(nodes)
        var idx = 0
        # Visit term "return"
        ++idx; target.print("return")
        # Recursive Visit expression_statement
        this.visit_expression_statement(nodes[idx++].nodes)

        output.push_back("RETP")
    end

    function visit_expression(nodes)
        var root_node = new parse_new_grammar.tree_type
        root_node.nodes = nodes
        root_node.root = "expression"
        output.push_back(root_node)
        var idx = 0
        # Recursive Visit assignment_expression
        this.visit_assignment_expression(nodes[idx++].nodes)
        # Recursive Visit expression_0_rep_2
        this.visit_expression_0_rep_2(nodes[idx++].nodes)
    end

    function visit_expression_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(",")
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                # Recursive Visit expression_0_rep_2
                this.visit_expression_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_assignment_expression(nodes)
        var idx = 0
        # Recursive Visit equality_expression
        this.visit_equality_expression(nodes[idx++].nodes)
        # Recursive Visit assignment_expression_0_opt_2
        this.visit_assignment_expression_0_opt_2(nodes[idx++].nodes)
    end
    
    function visit_assignment_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "assign_op")
                matched = true
                # Recursive Visit assign_op
                this.visit_assign_op(nodes[idx++].nodes)
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_assign_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "/=")
                matched = true
                # Visit term "/="
                ++idx; target.print("/=")
            end
            if !matched && (nodes[idx].root == "*=")
                matched = true
                # Visit term "*="
                ++idx; target.print("*=")
            end
            if !matched && (nodes[idx].root == "-=")
                matched = true
                # Visit term "-="
                ++idx; target.print("-=")
            end
            if !matched && (nodes[idx].root == "+=")
                matched = true
                # Visit term "+="
                ++idx; target.print("+=")
            end
            if !matched && (nodes[idx].root == "=")
                matched = true
                # Visit term "="
                ++idx; target.print("=")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_equality_expression(nodes)
        var idx = 0
        # Recursive Visit relat_expression
        this.visit_relat_expression(nodes[idx++].nodes)
        # Recursive Visit equality_expression_0_opt_2
        this.visit_equality_expression_0_opt_2(nodes[idx++].nodes)
    end
    
    function visit_equality_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "equal_op")
                matched = true
                # Recursive Visit equal_op
                this.visit_equal_op(nodes[idx++].nodes)
                # Recursive Visit equality_expression
                this.visit_equality_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_equal_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "!=")
                matched = true
                # Visit term "!="
                ++idx; target.print("!=")
            end
            if !matched && (nodes[idx].root == "==")
                matched = true
                # Visit term "=="
                ++idx; target.print("==")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    
    function visit_relat_expression(nodes)
        var idx = 0
        # Recursive Visit additive_expression
        this.visit_additive_expression(nodes[idx++].nodes)
        # Recursive Visit relat_expression_0_opt_2
        this.visit_relat_expression_0_opt_2(nodes[idx++].nodes)
    end

    function visit_relat_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "relat_op")
                matched = true
                # Recursive Visit relat_op
                this.visit_relat_op(nodes[idx++].nodes)
                # Recursive Visit relat_expression
                this.visit_relat_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_relat_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "<=")
                matched = true
                # Visit term "<="
                ++idx; target.print("<=")
            end
            if !matched && (nodes[idx].root == ">=")
                matched = true
                # Visit term ">="
                ++idx; target.print(">=")
            end
            if !matched && (nodes[idx].root == "<")
                matched = true
                # Visit term "<"
                ++idx; target.print("<")
            end
            if !matched && (nodes[idx].root == ">")
                matched = true
                # Visit term ">"
                ++idx; target.print(">")
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    
    function visit_additive_expression(nodes)
        var idx = 0
        # Recursive Visit multiplicative_expression
        this.visit_multiplicative_expression(nodes[idx++].nodes)
        # Recursive Visit additive_expression_0_opt_2
        this.visit_additive_expression_0_opt_2(nodes[idx++].nodes)
    end


    function visit_additive_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "add_op")
                matched = true
                # Recursive Visit add_op
                this.visit_add_op(nodes[idx++].nodes)
                # Recursive Visit additive_expression
                this.visit_additive_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_add_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (nodes[idx].root == "+")
                matched = true
                # Visit term "+"
                ++idx; target.print("+")
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    function visit_multiplicative_expression(nodes)
        var idx = 0
        # Recursive Visit unary_expression
        this.visit_unary_expression(nodes[idx++].nodes)
        # Recursive Visit multiplicative_expression_0_opt_2
        this.visit_multiplicative_expression_0_opt_2(nodes[idx++].nodes)
    end


    function visit_multiplicative_expression_0_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "mul_op")
                matched = true
                # Recursive Visit mul_op
                this.visit_mul_op(nodes[idx++].nodes)
                # Recursive Visit multiplicative_expression
                this.visit_multiplicative_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_mul_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "/")
                matched = true
                # Visit term "/"
                ++idx; target.print("/")
            end
            if !matched && (nodes[idx].root == "*")
                matched = true
                # Visit term "*"
                ++idx; target.print("*")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_unary_expression(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "postfix_expression")
                matched = true
                # Recursive Visit postfix_expression
                this.visit_postfix_expression(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == "sadd_op")
                matched = true
                # Recursive Visit sadd_op
                this.visit_sadd_op(nodes[idx++].nodes)
                # Recursive Visit unary_expression
                this.visit_unary_expression(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_sadd_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (nodes[idx].root == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (nodes[idx].root == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_expression(nodes)
        var idx = 0
        # Recursive Visit primary_expression
        this.visit_primary_expression(nodes[idx++].nodes)
        # Recursive Visit postfix_expression_0_rep_2
        this.visit_postfix_expression_0_rep_2(nodes[idx++].nodes)
    end

    function visit_postfix_expression_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "postfix_extend_part")
                matched = true
                # Recursive Visit postfix_extend_part
                this.visit_postfix_extend_part(nodes[idx++].nodes)
                # Recursive Visit postfix_expression_0_rep_2
                this.visit_postfix_expression_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "post_op")
                matched = true
                # Recursive Visit post_op
                this.visit_post_op(nodes[idx++].nodes)
            end
            if !matched && (nodes[idx].root == ".")
                matched = true
                # Visit term "."
                ++idx; target.print(".")
                # Visit ID token
                target.print(nodes[idx++].nodes[0].root)
            end
            if !matched && (nodes[idx].root == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit postfix_extend_part_1_opt_2
                this.visit_postfix_extend_part_1_opt_2(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched && (nodes[idx].root == "[")
                matched = true
                # Visit term "["
                ++idx; target.print("[")
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
                # Visit term "]"
                ++idx; target.print("]")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part_1_opt_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "assignment_expression")
                matched = true
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                # Recursive Visit postfix_extend_part_1_opt_2_0_rep_2
                this.visit_postfix_extend_part_1_opt_2_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_postfix_extend_part_1_opt_2_0_rep_2(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(",")
                # Recursive Visit assignment_expression
                this.visit_assignment_expression(nodes[idx++].nodes)
                # Recursive Visit postfix_extend_part_1_opt_2_0_rep_2
                this.visit_postfix_extend_part_1_opt_2_0_rep_2(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_post_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (nodes[idx].root == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function visit_primary_expression(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit expression
                this.visit_expression(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched && (nodes[idx].root == "NUMBER")
                matched = true
                # Visit NUMBER token
                target.print(nodes[idx++].nodes[0].root)
            end
            if !matched && (nodes[idx].root == "ID")
                matched = true
                # Visit ID token
                target.print(nodes[idx++].nodes[0].root)
            end
            if !matched
            	# Error
            	return
            end
        end
    end


    function visit_struct_specifier(nodes)
        var idx = 0
        # Visit term "struct"
        ++idx; target.print("struct")
        # Visit ID token
        target.print(nodes[idx++].nodes[0].root)
        # Visit term "{"
        ++idx; target.println("{")
        # Recursive Visit struct_specifier_0_rep_4
        this.visit_struct_specifier_0_rep_4(nodes[idx++].nodes)
        # Visit term "}"
        ++idx; target.print("}")
        # Recursive Visit struct_specifier_0_opt_6
        this.visit_struct_specifier_0_opt_6(nodes[idx++].nodes)
        # Visit term ";"
        ++idx; target.println(";")
    end
    


    function visit_struct_specifier_0_opt_6(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "ID")
                matched = true
                # Visit ID token
                target.print(nodes[idx++].nodes[0].root)
            end
            if !matched
            	# Error
            	return
            end
        end
    end





    function visit_struct_specifier_0_rep_4(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (nodes[idx].root == "NULL")
                matched = true
                # Visit NULL token
                # target.print(nodes[idx++].root)
            end
            if !matched && (nodes[idx].root == "declaration")
                matched = true
                # Recursive Visit declaration
                this.visit_declaration(nodes[idx++].nodes)
                # Recursive Visit struct_specifier_0_rep_4
                this.visit_struct_specifier_0_rep_4(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end

    function show_output()
        foreach iter in output
            if typeid iter == typeid parse_new_grammar.tree_type
                system.out.println("expression")
            else
                system.out.println(iter)
            end
        end
    end


    function run(ast)
        this.target = system.out
        this.visit_program(ast.nodes)
        show_output()
    end
end
